- [General Concept](#general-concept)
- [Detection](#detection)
- [Types](#types)
  - [Reflected XXS](#reflected-xxs)
  - [Stored XXS](#stored-xxs)
  - [DOM-Based XXS](#dom-based-xxs)
- [Contexts](#contexts)
  - [Between HTML Tags](#between-html-tags)
  - [In HTML Tag Attributes](#in-html-tag-attributes)
  - [Into JS](#into-js)
  - [Breaking Out of JS string](#breaking-out-of-js-string)
  - [HTML Encoding](#html-encoding)
  - [JS Template Literals](#js-template-literals)
  - [Via Client-Side Template Injection](#via-client-side-template-injection)
- [Dangling Markup Injection](#dangling-markup-injection)
- [Prevention](#prevention)
  - [Content Security Policy](#content-security-policy)
  - [Language Specific](#language-specific)
    - [PHP](#php)
    - [Java](#java)
- [References](#references)

# General Concept
Cross-site scripting is a WebSec vuln that allows attackers to circumvent the same 
origin policy and lets them masquerade as a victim user (able to carry out actions as them
and give access to their data). If they impersonate a privileged user, then they might be
able to gain full control over the app. 

XXS manipulates a website so that it returns malicious JS to users. When the JS executes 
in the browser, the attacker can fully compromise the user's interaction with the application. 

# Detection
Can confirm most kinds by injecting a payload that causes your browser to execute some
arbitrary JS. Common practice to use the `alert()` function because it's hard to miss. 
In Chrome >=v92 cross-origin iframes (which are used to construct more advanced XXS attacks)
are prevented from calling `alert()` so PortSwigger recommends using `print()`
[[1]](https://portswigger.net/research/alert-is-dead-long-live-print). 

To manually test for reflected, stored, and URL parameter-based DOM XXS, usually have to
submit some simple + unique input  into every entry point in the app, IDing every location
where the input is returned in HTTP responses/DOM, and then testing each location to find out
if a suitable input can be used to execute arbitrary JS. 

To manually test for other DOM-based XXS, you kinda just have to read the site's JS code. 

Can also be found with tools like Burp Suite's web vuln scanner. 

# Types
| Type | Summary |
| ---- | ------- |
| Reflected XXS | Malicious script comes from the current HTTP request |
| Stored XXS | Malicious script comes from the website's database |
| DOM-Based XXS | The vulnerability is in the client-side code rather than server-side |

## Reflected XXS
Simplest variety. When an application receives data in an HTTP request
that includes the data within the immediate response in an unsafe way. 

If the site doesn't do any extra processing, the attacker can construct the URL
and if the user visits, the script will run as the user, giving it access to any action/data
the user has access to

```
Example:

  **intended use**
  https://insecure-site.com/status?message=All+is+well.
  <p>Status: All is well.</p>

  **attacker use**
  https://insecure-site.com/status?message=<script>...</script>
  <p>Status: <script>...</script>
```

Because it's delivered through a link that the user needs to click on, it's generally less 
severe than stored XXS. 

## Stored XXS
Also known as persistent or second-order XXS. When an app receives data from an untrusted source 
and includes that data within its later HTTP responses in an unsafe way. 

The data might be submitted via HTTP requests (comments on a blog post, user nicknames, 
contact details, etc) but it can also come from other untrusted sources, like a webmail 
application displaying messages received over SMTP, a marketing application displaying 
social media posts, or a network monitoring application displaying packet data from network 
traffic.

```
Example:
  **intended use**
  <p>Hello, this is my message!</p>

  **attacker use**
  <p><script>...</script></p>

If there's a message board that lets users submit messages that get displayed to other users
and those messages aren't processed at all, it's vulnerable
```

## DOM-Based XXS
When an app has client-side JS that processes data  from an untrusted source in an unsafe way, 
usually by writing the data back to the DOM. 

Typically, the input field would be populated from part of the HTTP request, such as a URL 
query string parameter, allowing the attacker to deliver an attack using a malicious URL
ala reflected XXS. 
```
Example:
  var search = document.getElementById('search').value;
  var results = document.getElementById('results');
  results.innerHTML = 'You searched for: ' + search;

  You searched for: <img src=1 onerror='...'>
```
# Contexts
When testing for reflected/stored XXS, a key task is to identify the XXS context:
- The location within the response where attacker-controllable data appears
- Any input validation/other processing performed on that data by the app

## Between HTML Tags
When the context is text between HTML tags, you need to introduce some new HTML
tags designed to trigger JS execution

```
Example:
  <script>alert(1)</script>
  or
  <img src=1 onerror=alert(1) />
```

## In HTML Tag Attributes
You might be able to terminate the attribute value, close the tag, and introduce a new one

```
Example:
  "><script>alert(1)</script>
```

More commonly, the angle brackets are blocked/encoded, so you can't reak out of the tag. 
If you can terminate the attribute value, you can usually introduce a new attribute that creates
a scriptable context, such as an event handler.

```
Example:
  " autofocus onfocux=alert(1) x="

The trailing x=" is to repair the following markup
```

Sometimes the HTML tag attribute can crate a scriptable context, like the `href` attribute on an
anchor tag. 

```
Example:
  <a href="javascript:alert(1)">
```

## Into JS

## Breaking Out of JS string

## HTML Encoding

## JS Template Literals

## Via Client-Side Template Injection

# Dangling Markup Injection

# Prevention
| Method | Explanation |
| ------ | ----------- |
| Filter input on arrival | When user input is received, filter as strictly as possible based on expected/valid input |
| Encode data on output | When user-controllable data is output in HTTP responses encode it to prevent it from being interpreted as active content. This might require applying combos of HTML, URL, JS, and CSS encoding. |
| Use appropriate response headers | Use `Content-Type` and `X-Content-Type-Options` headers so browsers correctly interpret responses that aren't supposed to have any HTML or JS |
| Content Security Policy | Last defence to reduce severity of XXS vulns that still occur |

## Content Security Policy
CSP is a browser mechanism that aims to mitigate the impact of XXS and some other 
vulnerabilities. If an app that uses CSP contains XXS-like behavior, the CSP 
might hinder or prevent exploitation, but it can often be circumvented.

## Language Specific
### PHP
Filter inputs with a whitelist of allowed characters that use type hints/casting. 
Escape outputs with `htmlentities` and `ENT_QUOTES` for HTML contexts, or JS Unicode escapes 
for JS contexts. 

### Java
Filter inputs with a whitelist of allowed characters. 
Use a library such as Google Guave for HTML-encode output for HTML contexts or use JS 
Unicode escapes for JS contexts. 

# References
[PortSwigger XXS Cheat Sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)
