- [General Concept](#general-concept)
- [Detection](#detection)
- [Types](#types)
  - [Reflected XXS](#reflected-xxs)
  - [Stored XXS](#stored-xxs)
  - [DOM-Based XXS](#dom-based-xxs)
- [Dangling Markup Injection](#dangling-markup-injection)
- [Prevention](#prevention)
  - [Content Security Policy](#content-security-policy)

# General Concept
Cross-site scripting is a WebSec vuln that allows attackers to circumvent the same 
origin policy and lets them masquerade as a victim user (able to carry out actions as them
and give access to their data). If they impersonate a privileged user, then they might be
able to gain full control over the app. 

XXS manipulates a website so that it returns malicious JS to users. When the JS executes 
in the browser, the attacker can fully compromise the user's interaction with the application. 

# Detection
Can confirm most kinds by injecting a payload that causes your browser to execute some
arbitrary JS. Common practice to use the `alert()` function because it's hard to miss. 
In Chrome >=v92 cross-origin iframes (which are used to construct more advanced XXS attacks)
are prevented from calling `alert()` so PortSwigger recommends using `print()`
[[1]](https://portswigger.net/research/alert-is-dead-long-live-print). 

To manually test for reflected, stored, and URL parameter-based DOM XXS, usually have to
submit some simple + unique input  into every entry point in the app, IDing every location
where the input is returned in HTTP responses/DOM, and then testing each location to find out
if a suitable input can be used to execute arbitrary JS. 

To manually test for other DOM-based XXS, you kinda just have to read the site's JS code. 

Can also be found with tools like Burp Suite's web vuln scanner. 

# Types
| Type | Summary |
| ---- | ------- |
| Reflected XXS | Malicious script comes from the current HTTP request |
| Stored XXS | Malicious script comes from the website's database |
| DOM-Based XXS | The vulnerability is in the client-side code rather than server-side |

## Reflected XXS
Simplest variety. When an application receives data in an HTTP request
that includes the data within the immediate response in an unsafe way. 

If the site doesn't do any extra processing, the attacker can construct the URL
and if the user visits, the script will run as the user, giving it access to any action/data
the user has access to

```
Example:

  **intended use**
  https://insecure-site.com/status?message=All+is+well.
  <p>Status: All is well.</p>

  **attacker use**
  https://insecure-site.com/status?message=<script>...</script>
  <p>Status: <script>...</script>
```

## Stored XXS
Also known as persistent or second-order XXS. When an app receives data from an untrusted source 
and includes that data within its later HTTP responses in an unsafe way. 

The data might be submitted via HTTP requests (comments on a blog post, user nicknames, 
contact details, etc) but it can also come from other untrusted sources, like a webmail 
application displaying messages received over SMTP, a marketing application displaying 
social media posts, or a network monitoring application displaying packet data from network 
traffic.

```
Example:
  **intended use**
  <p>Hello, this is my message!</p>

  **attacker use**
  <p><script>...</script></p>

If there's a message board that lets users submit messages that get displayed to other users
and those messages aren't processed at all, it's vulnerable
```

## DOM-Based XXS
When an app has client-side JS that processes data  from an untrusted source in an unsafe way, 
usually by writing the data back to the DOM. 

Typically, the input field would be populated from part of the HTTP request, such as a URL 
query string parameter, allowing the attacker to deliver an attack using a malicious URL
ala reflected XXS. 
```
Example:
  var search = document.getElementById('search').value;
  var results = document.getElementById('results');
  results.innerHTML = 'You searched for: ' + search;

  You searched for: <img src=1 onerror='...'>
```
# Dangling Markup Injection

# Prevention
| Method | Explanation |
| ------ | ----------- |
| Filter input on arrival | When user input is received, filter as strictly as possible based on expected/valid input |
| Encode data on output | When user-controllable data is output in HTTP responses encode it to prevent it from being interpreted as active content. This might require applying combos of HTML, URL, JS, and CSS encoding. |
| Use appropriate response headers | Use `Content-Type` and `X-Content-Type-Options` headers so browsers correctly interpret responses that aren't supposed to have any HTML or JS |
| Content Security Policy | Last defence to reduce severity of XXS vulns that still occur |

## Content Security Policy
CSP is a browser mechanism that aims to mitigate the impact of XXS and some other 
vulnerabilities. If an app that uses CSP contains XXS-like behavior, the CSP 
might hinder or prevent exploitation, but it can often be circumvented.


  
